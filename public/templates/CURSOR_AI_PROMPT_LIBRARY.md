# Cursor AI Prompt Library for EFTDM

## Overview
This library contains pre-built prompts for each phase of the EFTDM methodology, optimized for Cursor AI to accelerate your development process.

## How to Use
1. Copy the relevant prompt for your current phase
2. Paste into Cursor AI chat
3. Provide your specific project context
4. Execute the generated code/analysis

---

## Phase 1: FSD Analysis & Design Integration

### UXD Image Analysis
```
Analyze this UXD image and extract the following information:
1. UI components and their hierarchy
2. Layout structure and spacing
3. Color scheme and typography
4. Interactive elements and states
5. Responsive design considerations

Please provide:
- Component mapping with specifications
- CSS/Tailwind classes for styling
- Accessibility considerations
- Mobile responsiveness requirements
```

### Figma Integration
```
Connect to this Figma design and extract:
1. Design system specifications
2. Component library details
3. Spacing and typography scales
4. Color palette and tokens
5. Icon and asset specifications

Generate:
- Design system documentation
- Component specifications
- CSS variables and tokens
- Asset optimization recommendations
```

### Mermaid Diagram Generation
```
Create Mermaid diagrams for this user journey:
1. User flow diagram showing all paths
2. Decision tree for user choices
3. System interaction diagram
4. Data flow diagram

Include:
- User actions and system responses
- Error handling and edge cases
- Integration points
- Performance considerations
```

---

## Phase 2: Implementation Planning

### Architecture Design
```
Design a scalable architecture for this project:
1. System components and their relationships
2. Data flow and API design
3. Database schema and relationships
4. Security and authentication strategy
5. Performance and scalability considerations

Provide:
- Architecture diagrams
- Technology stack recommendations
- Database design
- API specifications
- Security implementation plan
```

### Technology Stack Selection
```
Recommend the optimal technology stack for this project:
- Frontend framework and libraries
- Backend framework and services
- Database and storage solutions
- Authentication and security
- Deployment and hosting

Consider:
- Project requirements and constraints
- Team expertise and preferences
- Scalability and performance needs
- Cost and maintenance factors
- Future growth and expansion
```

---

## Phase 3: Project Setup

### Project Structure Setup
```
Create a complete project structure for this application:
1. Frontend and backend directories
2. Configuration files and settings
3. Development and build scripts
4. Testing and quality assurance setup
5. Documentation and README files

Include:
- Package.json configurations
- Environment variables setup
- Git configuration and workflows
- CI/CD pipeline configuration
- Development tools and extensions
```

### Environment Configuration
```
Set up development environment for this project:
1. Local development server configuration
2. Database setup and migrations
3. Authentication and security setup
4. API endpoints and testing
5. Frontend build and deployment

Provide:
- Environment configuration files
- Database setup scripts
- API testing setup
- Frontend development server
- Build and deployment scripts
```

---

## Phase 4: Backend Implementation

### API Development
```
Generate REST API endpoints for this specification:
1. CRUD operations for all entities
2. Authentication and authorization
3. Input validation and error handling
4. Database integration and queries
5. Security and rate limiting

Include:
- API route definitions
- Middleware and validation
- Database models and schemas
- Error handling and responses
- Security implementations
```

### Database Design
```
Design and implement database schema for this application:
1. Entity relationships and constraints
2. Indexes and performance optimization
3. Data validation and integrity
4. Migration scripts and seeding
5. Backup and recovery procedures

Provide:
- Database schema design
- Migration scripts
- Seed data scripts
- Query optimization
- Backup strategies
```

---

## Phase 5: Frontend Implementation

### Component Development
```
Create Vue.js components for this UXD design:
1. Component structure and props
2. State management and reactivity
3. Styling with Tailwind CSS
4. Accessibility and responsive design
5. Testing and validation

Include:
- Component templates and scripts
- CSS styling and responsive design
- Accessibility attributes
- Unit tests and validation
- Documentation and examples
```

### State Management
```
Implement state management for this application:
1. Global state structure and organization
2. Actions and mutations for data flow
3. Getters and computed properties
4. Persistence and synchronization
5. Error handling and loading states

Provide:
- Store configuration and modules
- Actions and mutations
- Getters and computed properties
- Persistence strategies
- Error handling patterns
```

---

## Phase 6: Integration & Testing

### Test Generation
```
Generate comprehensive tests for this application:
1. Unit tests for all components and functions
2. Integration tests for API endpoints
3. End-to-end tests for user journeys
4. Performance and load tests
5. Security and vulnerability tests

Include:
- Test setup and configuration
- Test cases and assertions
- Mock data and fixtures
- Test utilities and helpers
- CI/CD integration
```

### Performance Optimization
```
Optimize this application for performance:
1. Code splitting and lazy loading
2. Image and asset optimization
3. Caching strategies and implementation
4. Database query optimization
5. CDN and delivery optimization

Provide:
- Performance analysis and metrics
- Optimization strategies
- Implementation code
- Monitoring and measurement
- Continuous optimization
```

---

## Phase 7: Deployment & Optimization

### Deployment Configuration
```
Create production deployment configuration:
1. Environment variables and secrets
2. Build and deployment scripts
3. CI/CD pipeline configuration
4. Monitoring and logging setup
5. Backup and recovery procedures

Include:
- Deployment scripts and configuration
- Environment setup
- Monitoring configuration
- Backup strategies
- Rollback procedures
```

### Monitoring Setup
```
Set up comprehensive monitoring for this application:
1. Application performance monitoring
2. Error tracking and alerting
3. User analytics and behavior tracking
4. Security monitoring and threat detection
5. Infrastructure and resource monitoring

Provide:
- Monitoring configuration
- Alert rules and notifications
- Dashboard and visualization
- Analytics implementation
- Security monitoring setup
```

---

## General Development Prompts

### Code Review and Optimization
```
Review this code and provide:
1. Code quality assessment
2. Performance optimization suggestions
3. Security vulnerability analysis
4. Best practices recommendations
5. Refactoring suggestions

Include:
- Code quality metrics
- Performance benchmarks
- Security analysis
- Improvement recommendations
- Refactored code examples
```

### Documentation Generation
```
Generate comprehensive documentation for this code:
1. API documentation with examples
2. Component documentation and usage
3. Architecture and design decisions
4. Deployment and maintenance guides
5. Troubleshooting and FAQ

Provide:
- API documentation
- Component documentation
- Architecture documentation
- Deployment guides
- Troubleshooting guides
```

---

## Usage Tips

1. **Be Specific**: Provide detailed context about your project
2. **Iterate**: Use follow-up prompts to refine results
3. **Validate**: Always review and test generated code
4. **Customize**: Adapt prompts to your specific needs
5. **Combine**: Use multiple prompts for comprehensive solutions

## Best Practices

- Always test generated code before production use
- Review AI suggestions for security and performance
- Maintain your own coding standards and conventions
- Use version control for all generated code
- Document any customizations or modifications
